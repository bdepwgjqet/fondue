#TopCoder ContestApplet Preferences File
#Mon Feb 06 16:48:06 CST 2012
com.topcoder.client.contestApplet.common.LocalPreferences.menufont=Arial
com.topcoder.client.contestApplet.common.LocalPreferences.menufontsize=10
com.topcoder.client.contestApplet.common.LocalPreferences.commonclasspath=
com.topcoder.client.contestApplet.LocalPreferences.connectionType=DIRECT
com.topcoder.jmaContestApplet.frames.codingframe.location=683\:19
com.topcoder.jmaContestApplet.frames.codingframe.size=681\:747
com.topcoder.jmaContestApplet.frames.codingframe.dividerloc=422
com.topcoder.jmaContestApplet.frames.sourceViewer.location=683\:19
com.topcoder.jmaContestApplet.frames.sourceViewer.size=681\:747
com.topcoder.jmaContestApplet.frames.sourceViewer.dividerloc=80
fileeditor.config.dirName=/home/bdep__/acmt/topcoder/codes
fileeditor.config.fileName=problem
fileeditor.config.beginCut=// BEGIN CUT HERE
fileeditor.config.endCut=// END CUT HERE
fileeditor.config.probdescfileextnsion=html
fileeditor.config.signaturefilename=
fileeditor.config.lineComments=false
fileeditor.config.overrideFileName=false
fileeditor.config.provideBreaks=false
fileeditor.config.probdescfilewrite=true
fileeditor.config.breakAt=60
fileeditor.config.htmldesc=true
fileeditor.config.backup=false
fileeditor.config.javatemplate=$BEGINCUT$\n$PROBLEMDESC$\n$ENDCUT$\nimport java.util.*;\npublic class $CLASSNAME$ {\n\tpublic $RC$ $METHODNAME$($METHODPARMS$) {\n\t\t\n\t}\n\tpublic static void main(String[] args) {\n\t\t$CLASSNAME$ temp \= new $CLASSNAME$();\n\t\tSystem.out.println(temp.$METHODNAME$($METHODPARMS$));\n\t}\n}
fileeditor.config.cpptemplate=$BEGINCUT$\n$PROBLEMDESC$\n$ENDCUT$\n\#line $NEXTLINENUMBER$ "$FILENAME$"\n\#include <cstdlib>\n\#include <cctype>\n\#include <cstring>\n\#include <cstdio>\n\#include <cmath>\n\#include <algorithm>\n\#include <vector>\n\#include <string>\n\#include <iostream>\n\#include <map>\n\#include <set>\n\#include <queue>\n\#include <fstream>\n\#include <iomanip>\n\#include <list>\n\#include <strstream>\n\#include <stdexcept>\n\#include <functional>\n\#include <ctime>\n\#include <deque> \n\#include <stack> \n\#include <bitset> \n\#include <numeric> \n\#include <utility> \n\#include <sstream> \nusing namespace std;\n\n//BEGINTEMPLATE_BY_ACRUSH_TOPCODER \n\#define SIZE(X) ((int)(X.size()))//NOTES\:SIZE( \n\#define LENGTH(X) ((int)(X.length()))//NOTES\:LENGTH( \n\#define MP(X,Y) make_pair(X,Y)//NOTES\:MP( \ntypedef long long int64;//NOTES\:int64 \ntypedef unsigned long long uint64;//NOTES\:uint64 \n\#define two(X) (1<<(X))//NOTES\:two( \n\#define twoL(X) (((int64)(1))<<(X))//NOTES\:twoL( \n\#define contain(S,X) (((S)&two(X))\!\=0)//NOTES\:contain( \n\#define containL(S,X) (((S)&twoL(X))\!\=0)//NOTES\:containL( \nconst double pi\=acos(-1.0);//NOTES\:pi \nconst double eps\=1e-5;//NOTES\:eps \ntemplate<class T> inline void checkmin(T &a,T b){if(b<a) a\=b;}//NOTES\:checkmin( \ntemplate<class T> inline void checkmax(T &a,T b){if(b>a) a\=b;}//NOTES\:checkmax( \ntemplate<class T> inline T sqr(T x){return x*x;}//NOTES\:sqr \ntypedef pair<int,int> ipair;//NOTES\:ipair \ntemplate<class T> inline T lowbit(T n){return (n^(n-1))&n;}//NOTES\:lowbit( \ntemplate<class T> inline int countbit(T n){return (n\=\=0)?0\:(1+countbit(n&(n-1)));}//NOTES\:countbit( \n//Numberic Functions \ntemplate<class T> inline T gcd(T a,T b)//NOTES\:gcd( \n  {if(a<0)return gcd(-a,b);if(b<0)return gcd(a,-b);return (b\=\=0)?a\:gcd(b,a%b);} \ntemplate<class T> inline T lcm(T a,T b)//NOTES\:lcm( \n  {if(a<0)return lcm(-a,b);if(b<0)return lcm(a,-b);return a*(b/gcd(a,b));} \ntemplate<class T> inline T euclide(T a,T b,T &x,T &y)//NOTES\:euclide( \n  {if(a<0){T d\=euclide(-a,b,x,y);x\=-x;return d;} \n    if(b<0){T d\=euclide(a,-b,x,y);y\=-y;return d;} \n    if(b\=\=0){x\=1;y\=0;return a;}else{T d\=euclide(b,a%b,x,y);T t\=x;x\=y;y\=t-(a/b)*y;return d;}} \ntemplate<class T> inline vector<pair<T,int> > factorize(T n)//NOTES\:factorize( \n  {vector<pair<T,int> > R;for (T i\=2;n>1;){if (n%i\=\=0){int C\=0;for (;n%i\=\=0;C++,n/\=i);R.push_back(make_pair(i,C));} \n    i++;if (i>n/i) i\=n;}if (n>1) R.push_back(make_pair(n,1));return R;} \ntemplate<class T> inline bool isPrimeNumber(T n)//NOTES\:isPrimeNumber( \n  {if(n<\=1)return false;for (T i\=2;i*i<\=n;i++) if (n%i\=\=0) return false;return true;} \ntemplate<class T> inline T eularFunction(T n)//NOTES\:eularFunction( \n  {vector<pair<T,int> > R\=factorize(n);T r\=n;for (int i\=0;i<R.size();i++)r\=r/R[i].first*(R[i].first-1);return r;} \n//Matrix Operations \nconst int MaxMatrixSize\=40;//NOTES\:MaxMatrixSize \ntemplate<class T> inline void showMatrix(int n,T A[MaxMatrixSize][MaxMatrixSize])//NOTES\:showMatrix( \n  {for (int i\=0;i<n;i++){for (int j\=0;j<n;j++)cout<<A[i][j];cout<<endl;}} \ntemplate<class T> inline T checkMod(T n,T m) {return (n%m+m)%m;}//NOTES\:checkMod( \ntemplate<class T> inline void identityMatrix(int n,T A[MaxMatrixSize][MaxMatrixSize])//NOTES\:identityMatrix( \n  {for (int i\=0;i<n;i++) for (int j\=0;j<n;j++) A[i][j]\=(i\=\=j)?1\:0;} \ntemplate<class T> inline void addMatrix(int n,T C[MaxMatrixSize][MaxMatrixSize],T A[MaxMatrixSize][MaxMatrixSize],T B[MaxMatrixSize][MaxMatrixSize])//NOTES\:addMatrix( \n  {for (int i\=0;i<n;i++) for (int j\=0;j<n;j++) C[i][j]\=A[i][j]+B[i][j];} \ntemplate<class T> inline void subMatrix(int n,T C[MaxMatrixSize][MaxMatrixSize],T A[MaxMatrixSize][MaxMatrixSize],T B[MaxMatrixSize][MaxMatrixSize])//NOTES\:subMatrix( \n  {for (int i\=0;i<n;i++) for (int j\=0;j<n;j++) C[i][j]\=A[i][j]-B[i][j];} \ntemplate<class T> inline void mulMatrix(int n,T C[MaxMatrixSize][MaxMatrixSize],T _A[MaxMatrixSize][MaxMatrixSize],T _B[MaxMatrixSize][MaxMatrixSize])//NOTES\:mulMatrix( \n  { T A[MaxMatrixSize][MaxMatrixSize],B[MaxMatrixSize][MaxMatrixSize]; \n  for (int i\=0;i<n;i++) for (int j\=0;j<n;j++) A[i][j]\=_A[i][j],B[i][j]\=_B[i][j],C[i][j]\=0; \n  for (int i\=0;i<n;i++) for (int j\=0;j<n;j++) for (int k\=0;k<n;k++) C[i][j]+\=A[i][k]*B[k][j];} \ntemplate<class T> inline void addModMatrix(int n,T m,T C[MaxMatrixSize][MaxMatrixSize],T A[MaxMatrixSize][MaxMatrixSize],T B[MaxMatrixSize][MaxMatrixSize])//NOTES\:addModMatrix( \n  {for (int i\=0;i<n;i++) for (int j\=0;j<n;j++) C[i][j]\=checkMod(A[i][j]+B[i][j],m);} \ntemplate<class T> inline void subModMatrix(int n,T m,T C[MaxMatrixSize][MaxMatrixSize],T A[MaxMatrixSize][MaxMatrixSize],T B[MaxMatrixSize][MaxMatrixSize])//NOTES\:subModMatrix( \n  {for (int i\=0;i<n;i++) for (int j\=0;j<n;j++) C[i][j]\=checkMod(A[i][j]-B[i][j],m);} \ntemplate<class T> inline T multiplyMod(T a,T b,T m) {return (T)((((int64)(a)*(int64)(b)%(int64)(m))+(int64)(m))%(int64)(m));}//NOTES\:multiplyMod( \ntemplate<class T> inline void mulModMatrix(int n,T m,T C[MaxMatrixSize][MaxMatrixSize],T _A[MaxMatrixSize][MaxMatrixSize],T _B[MaxMatrixSize][MaxMatrixSize])//NOTES\:mulModMatrix( \n  { T A[MaxMatrixSize][MaxMatrixSize],B[MaxMatrixSize][MaxMatrixSize]; \n  for (int i\=0;i<n;i++) for (int j\=0;j<n;j++) A[i][j]\=_A[i][j],B[i][j]\=_B[i][j],C[i][j]\=0; \n  for (int i\=0;i<n;i++) for (int j\=0;j<n;j++) for (int k\=0;k<n;k++) C[i][j]\=(C[i][j]+multiplyMod(A[i][k],B[k][j],m))%m;} \ntemplate<class T> inline T powerMod(T p,int e,T m)//NOTES\:powerMod( \n  {if(e\=\=0)return 1%m;else if(e%2\=\=0){T t\=powerMod(p,e/2,m);return multiplyMod(t,t,m);}else return multiplyMod(powerMod(p,e-1,m),p,m);} \n//Point&Line \ndouble dist(double x1,double y1,double x2,double y2){return sqrt(sqr(x1-x2)+sqr(y1-y2));}//NOTES\:dist( \ndouble distR(double x1,double y1,double x2,double y2){return sqr(x1-x2)+sqr(y1-y2);}//NOTES\:distR( \ntemplate<class T> T cross(T x0,T y0,T x1,T y1,T x2,T y2){return (x1-x0)*(y2-y0)-(x2-x0)*(y1-y0);}//NOTES\:cross( \nint crossOper(double x0,double y0,double x1,double y1,double x2,double y2)//NOTES\:crossOper( \n  {double t\=(x1-x0)*(y2-y0)-(x2-x0)*(y1-y0);if (fabs(t)<\=eps) return 0;return (t<0)?-1\:1;} \nbool isIntersect(double x1,double y1,double x2,double y2,double x3,double y3,double x4,double y4)//NOTES\:isIntersect( \n  {return crossOper(x1,y1,x2,y2,x3,y3)*crossOper(x1,y1,x2,y2,x4,y4)<0 && crossOper(x3,y3,x4,y4,x1,y1)*crossOper(x3,y3,x4,y4,x2,y2)<0;} \nbool isMiddle(double s,double m,double t){return fabs(s-m)<\=eps || fabs(t-m)<\=eps || (s<m)\!\=(t<m);}//NOTES\:isMiddle( \n//Translator \nbool isUpperCase(char c){return c>\='A' && c<\='Z';}//NOTES\:isUpperCase( \nbool isLowerCase(char c){return c>\='a' && c<\='z';}//NOTES\:isLowerCase( \nbool isLetter(char c){return c>\='A' && c<\='Z' || c>\='a' && c<\='z';}//NOTES\:isLetter( \nbool isDigit(char c){return c>\='0' && c<\='9';}//NOTES\:isDigit( \nchar toLowerCase(char c){return (isUpperCase(c))?(c+32)\:c;}//NOTES\:toLowerCase( \nchar toUpperCase(char c){return (isLowerCase(c))?(c-32)\:c;}//NOTES\:toUpperCase( \ntemplate<class T> string toString(T n){ostringstream ost;ost<<n;ost.flush();return ost.str();}//NOTES\:toString( \nint toInt(string s){int r\=0;istringstream sin(s);sin>>r;return r;}//NOTES\:toInt( \nint64 toInt64(string s){int64 r\=0;istringstream sin(s);sin>>r;return r;}//NOTES\:toInt64( \ndouble toDouble(string s){double r\=0;istringstream sin(s);sin>>r;return r;}//NOTES\:toDouble( \ntemplate<class T> void stoa(string s,int &n,T A[]){n\=0;istringstream sin(s);for(T v;sin>>v;A[n++]\=v);}//NOTES\:stoa( \ntemplate<class T> void atos(int n,T A[],string &s){ostringstream sout;for(int i\=0;i<n;i++){if(i>0)sout<<' ';sout<<A[i];}s\=sout.str();}//NOTES\:atos( \ntemplate<class T> void atov(int n,T A[],vector<T> &vi){vi.clear();for (int i\=0;i<n;i++) vi.push_back(A[i]);}//NOTES\:atov( \ntemplate<class T> void vtoa(vector<T> vi,int &n,T A[]){n\=vi.size();for (int i\=0;i<n;i++)A[i]\=vi[i];}//NOTES\:vtoa( \ntemplate<class T> void stov(string s,vector<T> &vi){vi.clear();istringstream sin(s);for(T v;sin>>v;vi.push_bakc(v));}//NOTES\:stov( \ntemplate<class T> void vtos(vector<T> vi,string &s){ostringstream sout;for (int i\=0;i<vi.size();i++){if(i>0)sout<<' ';sout<<vi[i];}s\=sout.str();}//NOTES\:vtos( \n//Fraction \ntemplate<class T> struct Fraction{T a,b;Fraction(T a\=0,T b\=1);string toString();};//NOTES\:Fraction \n  template<class T> Fraction<T>\:\:Fraction(T a,T b){T d\=gcd(a,b);a/\=d;b/\=d;if (b<0) a\=-a,b\=-b;this->a\=a;this->b\=b;} \n  template<class T> string Fraction<T>\:\:toString(){ostringstream sout;sout<<a<<"/"<<b;return sout.str();} \n  template<class T> Fraction<T> operator+(Fraction<T> p,Fraction<T> q){return Fraction<T>(p.a*q.b+q.a*p.b,p.b*q.b);} \n  template<class T> Fraction<T> operator-(Fraction<T> p,Fraction<T> q){return Fraction<T>(p.a*q.b-q.a*p.b,p.b*q.b);} \n  template<class T> Fraction<T> operator*(Fraction<T> p,Fraction<T> q){return Fraction<T>(p.a*q.a,p.b*q.b);} \n  template<class T> Fraction<T> operator/(Fraction<T> p,Fraction<T> q){return Fraction<T>(p.a*q.b,p.b*q.a);} \n//ENDTEMPLATE_BY_ACRUSH_TOPCODER\n\n\nclass $CLASSNAME$\n{\n        public\:\n        $RC$ $METHODNAME$($METHODPARMS$)\n        {\n                $CARETPOSITION$\n        }\n        $TESTCODE$\n};\n\n// BEGIN CUT HERE\nint main()\n{\n        $CLASSNAME$ ___test;\n        ___test.run_test(-1);\n        return 0;\n}\n// END CUT HERE\n
fileeditor.config.csharptemplate=using System;\r\nusing System.Collections;\r\npublic class $CLASSNAME$ {\r\n\tpublic $RC$ $METHODNAME$($METHODPARMS$) {\r\n\t\t$CARETPOSITION$\r\n\t}\r\n}
fileeditor.config.javaextension=java
fileeditor.config.cppextension=cpp
fileeditor.config.csharpextension=cs
editor.defaultname=MyEditor
editor.1.name=MyEditor
editor.1.entrypoint=codeprocessor.EntryPoint
editor.1.classpath=/home/bdep__/acmt/topcoder/plugins/TZTester.jar\:/home/bdep__/acmt/topcoder/plugins/FileEdit.jar\:/home/bdep__/acmt/topcoder/plugins/CodeProcessor.jar
editor.1.eager=0
editor.numplugins=1
codeprocessor.config.pluginentrypoint=fileedit.EntryPoint
codeprocessor.config.codeprocessor=tangentz.TZTester
